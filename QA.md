```
1.	Какой самый эффективный способ конкатенации строк?
```

https://golangify.com/concatenation

В порядке уменьшения производительности:

- копировать в слайс байт и переформатировать в строку

- strings.Builder

- str + str

- fmt.Sprintf


```
2.	Что такое интерфейсы, как они применяются в Go?
```
Интерфейсы - это контракты, они описывают методы, которые должны быть у другого типа,
обычно говорят, что что-то удовлетворяет/реализует интерфейс, если у данного типа есть соответствующие методы.
Пустой интерфейс реализует любой тип (ранее применялся вместо дженериков).
Интерфейсы можно использовать вместо параметров в сигнатуре функций.
Они помогают уменьшить дублирование кода.

```
3.	Чем отличаются RWMutex от Mutex?
```
Mutex (взаимное исключение) - защита критической секции программы (когда требуется эксклюзивный доступ к общему ресурсу, например счётчик)
RWMutex - блокировка чтения-записи, больше возможностей для контроля над памятью, чем у просто мьютекса,
хорошо подходит, когда много читателей и один писатель, так как можно блокировать только запись


```
4.	Чем отличаются буферизированные и не буферизированные каналы?
```
Небуферизированный канал создаётся функцией make без указания ёмкости, только одно значение;
У буферизированного канала задана ёмкость, поэтому в него можно писать данные без блокировки до того, как указанная ёмкость заполнится

```
5.	Какой размер у структуры struct{}{}?
```
0 байт

```
6.	Есть ли в Go перегрузка методов или операторов?
```

Перегрузка операторов — это способ, с помощью которого операторы могут выполнять операции, определенные пользователями. Операторы ведут себя в соответствии с переданными аргументами.
Перегрузка методов — это приём программирования, который позволяет разработчику в одном классе для методов с разными параметрами использовать одно и то же имя
Ни того, ни другого нет в Go.
```
7.	В какой последовательности будут выведены элементы map[int]int?

Пример:
m[0]=1
m[1]=124
m[2]=281
```

В любой, у мапы нет чёткой последовательности, от итерации к итерации может меняться
Если требуется стабильный порядок итераций, нужно поддерживать отдельную структуру данных, которая определяет этот порядок

```
8.	В чем разница make и new?
```
Функции ‘new’ и ‘make’ различаются тем, что:

‘new’ возвращает указатель вместо значения возвращаемое функцией ‘make’.
‘make’ имеет вариадический аргумент ‘size’.
‘make’ выделяет память и инциализирует только объекты типов: slice, map, or chan.

Встроенная функция new выделяет память (создает неименованную переменную и возваращет указатель на ее значение). Первый аргумент - тип (не значение), и возвращаемое значение - указатель на нулевое значение указанного типа.
var a = new(T)


```
9.	Сколько существует способов задать переменную типа slice или map?
```
Три: 
Var slice []int
Slice := []int{}
Slice := make([]int, 3, 3)

```
10.	Что выведет данная программа и почему?

func update(p *int) {
  b := 2
  p = &b
}

func main() {
  var (
     a = 1
     p = &a
  )
  fmt.Println(*p)
  update(p)
  fmt.Println(*p)
}
```

1
1

Так как изменение в другой функции, которая ничего не возвращает, а в go всё передаётся по значению, то во внешней функции изменения не произошло

```
11.	Что выведет данная программа и почему?

func main() {
  wg := sync.WaitGroup{}
  for i := 0; i < 5; i++ {
     wg.Add(1)
     go func(wg sync.WaitGroup, i int) {
        fmt.Println(i)
        wg.Done()
     }(wg, i)
  }
  wg.Wait()
  fmt.Println("exit")
}

???

```
```
12.	Что выведет данная программа и почему?


func main() {
  n := 0
  if true {
     n := 1
     n++
  }
  fmt.Println(n)
}
```

0, переменная была переопределена в зоне видимости внутри фигурных скобок

```
13.	Что выведет данная программа и почему?

func someAction(v []int8, b int8) {
  v[0] = 100
  v = append(v, b)
}

func main() {
  var a = []int8{1, 2, 3, 4, 5}
  someAction(a, 6)
  fmt.Println(a)
}
```

100 2 3 4 5

Так как v в другой функции без вывода, append не сработал, а v[0] изменило непосредственно первый элемент исходного массива
```
14.	Что выведет данная программа и почему?

func main() {
  slice := []string{"a", "a"}

  func(slice []string) {
     slice = append(slice, "a")
     slice[0] = "b"
     slice[1] = "b"
     fmt.Print(slice)
  }(slice)
  fmt.Print(slice)
}
```

b b a 
a a

по сути в анонимной функции мы создали новый слайс, используя append,
а за её пределами слайс остался неизменным
